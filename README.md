# Простой пример синхронизированного приложения на Java

Простой пример синхронизированного приложения на Java, которое моделирует банковский счет. 
В этом примере будет использован механизм синхронизации для предотвращения конфликтов при одновременном доступе нескольких потоков к общему ресурсу — банковскому счету.
Создадим класс BankAccount, который будет представлять счёт, а также несколько потоков, которые будут пытаться одновременно пополнять и снимать деньги.



## Объяснение кода:

### Класс BankAccount:

* Имеет переменную balance, которая представляет баланс счета.
* Методы withdraw и deposit имеют модификатор synchronized, чтобы обеспечить потокобезопасность. Это гарантирует, что только один поток может выполнять метод в данный момент времени для данного объекта.
* Классы WithdrawTask и DepositTask:
* Реализуют интерфейс Runnable, что позволяет выполнять соответствующие задачи в отдельных потоках. Они вызывают методы withdraw и deposit банковского счета.

### Класс Client:

* В методе Client создается экземпляр BankAccount с начальным балансом 1000.
* Создаются и запускаются несколько потоков для снятия и пополнения денег на счет.
* Используется метод join для ожидания завершения всех потоков перед выводом конечного баланса.

## Синхронизация:

* Код синхронизован с помощью ключевого слова synchronized, что предотвращает состояние гонки, когда два или более потока пытаются одновременно модифицировать общий ресурс (в нашем случае — баланс счета).
* Это гарантирует корректность операций над счетом и выводит правильные сообщения о снятии и пополнении, а также следит за правильностью состояния счета.

### Где использовать синхронизацию:

* Синхронизация особенно важна в многопоточных приложениях, когда несколько потоков обращаются к общим ресурсам, таким как:
* Банковские счета (как в этом примере).
* Рабочие очереди.
* Общие данные или кэш-память, которые могут быть изменены одновременно разными потоками.
* Ресурсы, требующие защиты от состояния гонки при записи или чтении данных.
